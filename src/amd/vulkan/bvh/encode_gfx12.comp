/*
 * Copyright © 2022 Friedrich Vock
 * Copyright © 2025 Valve Corporation
 *
 * SPDX-License-Identifier: MIT
 */

#version 460

#extension GL_GOOGLE_include_directive : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_KHR_memory_scope_semantics : require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define GFX12

#include "build_helpers.h"
#include "build_interface.h"
#include "encode.h"

layout(push_constant) uniform CONSTS
{
   encode_gfx12_args args;
};

void
set_parent(uint32_t child, uint32_t parent)
{
   uint64_t addr = args.output_base + args.output_bvh_offset - child / 16 * 4 - 4;
   DEREF(REF(uint32_t)(addr)) = parent;
}

void
main()
{
   if (gl_GlobalInvocationID.x >= DEREF(args.header).ir_internal_node_count)
      return;

   /* Revert the order so we start at the root */
   uint32_t global_id = DEREF(args.header).ir_internal_node_count - 1 - gl_GlobalInvocationID.x;

   uint32_t ir_leaf_node_size;
   switch (args.geometry_type) {
   case VK_GEOMETRY_TYPE_TRIANGLES_KHR: {
      ir_leaf_node_size = SIZEOF(vk_ir_triangle_node);
      break;
   }
   case VK_GEOMETRY_TYPE_AABBS_KHR: {
      ir_leaf_node_size = SIZEOF(vk_ir_aabb_node);
      break;
   }
   default:
      /* instances */
      ir_leaf_node_size = SIZEOF(vk_ir_instance_node);
      break;
   }

   uint32_t intermediate_leaf_nodes_size = args.leaf_node_count * ir_leaf_node_size;
   uint32_t dst_internal_offset = id_to_offset(RADV_BVH_ROOT_NODE);

   REF(vk_ir_box_node) intermediate_internal_nodes =
      REF(vk_ir_box_node) OFFSET(args.intermediate_bvh, intermediate_leaf_nodes_size);
   REF(vk_ir_box_node) src_node = INDEX(vk_ir_box_node, intermediate_internal_nodes, global_id);
   vk_ir_box_node src = DEREF(src_node);

   bool is_root_node = global_id == DEREF(args.header).ir_internal_node_count - 1;

   for (;;) {
      /* Make changes to the current node's BVH offset value visible. */
      memoryBarrier(gl_ScopeDevice, gl_StorageSemanticsBuffer,
                    gl_SemanticsAcquireRelease | gl_SemanticsMakeAvailable | gl_SemanticsMakeVisible);

      uint32_t bvh_offset = is_root_node ? id_to_offset(RADV_BVH_ROOT_NODE) : DEREF(src_node).bvh_offset;
      if (bvh_offset == VK_UNKNOWN_BVH_OFFSET)
         continue;

      if (bvh_offset == VK_NULL_BVH_OFFSET)
         break;

      REF(radv_gfx12_box_node) dst = REF(radv_gfx12_box_node)(args.output_base + (args.output_bvh_offset + bvh_offset));

      uint32_t node_id = pack_node_id(bvh_offset, radv_bvh_node_box32);

      uint32_t children[8];

      uint32_t found_child_count = 0;
      for (uint32_t i = 0; i < 2; i++) {
         if (src.children[i] != RADV_BVH_INVALID_NODE) {
            children[found_child_count] = src.children[i];
            found_child_count++;
         }
      }

      /* TODO: Collapse child nodes with high SAH values. */
      while (found_child_count < 8) {
         bool progress = false;
         for (int32_t i = 0; i < found_child_count; i++) {
            uint32_t child_id = children[i];
            if (ir_id_to_type(child_id) != vk_ir_node_internal)
               continue;

            progress = true;

            REF(vk_ir_box_node) child_node =
               REF(vk_ir_box_node) OFFSET(args.intermediate_bvh, ir_id_to_offset(child_id));
            uint32_t grandchildren[2] = DEREF(child_node).children;
            uint32_t valid_grandchild_count = 0;

            if (grandchildren[1] != RADV_BVH_INVALID_NODE)
               valid_grandchild_count++;

            if (grandchildren[0] != RADV_BVH_INVALID_NODE)
               valid_grandchild_count++;
            else
               grandchildren[0] = grandchildren[1];

            if (valid_grandchild_count > 1) {
               children[found_child_count] = grandchildren[1];
               found_child_count++;
            }

            if (valid_grandchild_count > 0) {
               children[i] = grandchildren[0];
            } else {
               found_child_count--;
               children[i] = children[found_child_count];
            }

            DEREF(child_node).bvh_offset = VK_NULL_BVH_OFFSET;

            if (found_child_count == 8)
               break;
         }

         if (!progress)
            break;
      }

      uint32_t child_leaf_nodes_size = 0;
      uint32_t child_internal_nodes_size = 0;
      for (uint32_t i = 0; i < found_child_count; i++) {
         uint32_t type = ir_id_to_type(children[i]);
         if (type == vk_ir_node_internal)
            child_internal_nodes_size += RADV_GFX12_BVH_NODE_SIZE;
         else if (type == vk_ir_node_instance)
            child_leaf_nodes_size += 2 * RADV_GFX12_BVH_NODE_SIZE;
         else
            child_leaf_nodes_size += RADV_GFX12_BVH_NODE_SIZE;
      }

      uint32_t dst_internal_offset = atomicAdd(DEREF(args.header).dst_node_offset, child_internal_nodes_size);
      uint32_t dst_leaf_offset = atomicAdd(DEREF(args.header).dst_leaf_node_offset, child_leaf_nodes_size);

      vec3 origin = src.base.aabb.min;
      vec3 extent = src.base.aabb.max - src.base.aabb.min;

      extent = uintBitsToFloat((floatBitsToUint(extent) + uvec3(0x7fffff)) & 0x7f800000);
      uvec3 extent_exponents = floatBitsToUint(extent) >> 23;

      DEREF(dst).internal_base_id = pack_node_id(dst_internal_offset, 0);
      DEREF(dst).primitive_base_id = pack_node_id(dst_leaf_offset, 0);
      DEREF(dst).origin = origin;
      DEREF(dst).child_count_exponents =
         extent_exponents.x | (extent_exponents.y << 8) | (extent_exponents.z << 16) | ((found_child_count - 1) << 28);
      DEREF(dst).obb_matrix_index = 0x7f;

      for (uint32_t i = 0; i < found_child_count; i++) {
         uint32_t child_id = children[i];
         uint32_t type = ir_id_to_type(child_id);
         uint32_t offset = ir_id_to_offset(child_id);

         uint32_t child_node_size_128b = 1;
         uint32_t encoded_type = 0;
         uint32_t dst_offset = 0;
         uint32_t cull_mask = 0xff;
         if (type == vk_ir_node_internal) {
            encoded_type = 5;
            dst_offset = dst_internal_offset;

            REF(vk_ir_box_node) child_node = REF(vk_ir_box_node) OFFSET(args.intermediate_bvh, offset);
            DEREF(child_node).bvh_offset = dst_internal_offset;

            dst_internal_offset += RADV_GFX12_BVH_NODE_SIZE;
         } else {
            dst_offset = dst_leaf_offset;

            /* Write leaf node offset. */
            uint32_t child_index = offset / ir_leaf_node_size;
            REF(uint32_t) child_dst_offset = REF(uint32_t)(args.output_base + args.leaf_node_offsets_offset);
            child_dst_offset = INDEX(uint32_t, child_dst_offset, child_index);
            DEREF(child_dst_offset) = dst_offset;

            VOID_REF dst_leaf_addr = args.output_base + args.output_bvh_offset + dst_leaf_offset;

            switch (args.geometry_type) {
            case VK_GEOMETRY_TYPE_TRIANGLES_KHR: {
               vk_ir_triangle_node src_node = DEREF(REF(vk_ir_triangle_node)(OFFSET(args.intermediate_bvh, offset)));
               radv_encode_triangle_gfx12(dst_leaf_addr, src_node);
               dst_leaf_offset += RADV_GFX12_BVH_NODE_SIZE;
               break;
            }
            case VK_GEOMETRY_TYPE_AABBS_KHR: {
               vk_ir_aabb_node src_node = DEREF(REF(vk_ir_aabb_node)(OFFSET(args.intermediate_bvh, offset)));
               radv_encode_aabb_gfx12(dst_leaf_addr, src_node);
               dst_leaf_offset += RADV_GFX12_BVH_NODE_SIZE;
               break;
            }
            default:
               /* instances */
               encoded_type = 6;
               child_node_size_128b = 2;

               vk_ir_instance_node src_node = DEREF(REF(vk_ir_instance_node)(OFFSET(args.intermediate_bvh, offset)));
               radv_encode_instance_gfx12(dst_leaf_addr, src_node);

               cull_mask = src_node.custom_instance_and_mask >> 24;

               dst_leaf_offset += 2 * RADV_GFX12_BVH_NODE_SIZE;

               break;
            }
         }

         vk_aabb child_aabb = DEREF(REF(vk_ir_node) OFFSET(args.intermediate_bvh, offset)).aabb;

         radv_gfx12_box_child child;
         /* TODO: subtree flags culling */
         child.dword0 = min(uint32_t(floor((child_aabb.min.x - origin.x) / extent.x * float(0x1000))), 0xfff) |
                        (min(uint32_t(floor((child_aabb.min.y - origin.y) / extent.y * float(0x1000))), 0xfff) << 12);
         /* TODO: subtree mask culling */
         child.dword1 =
            min(uint32_t(floor((child_aabb.min.z - origin.z) / extent.z * float(0x1000))), 0xfff) |
            (min(uint32_t(ceil((child_aabb.max.x - origin.x) / extent.x * float(0x1000))) - 1, 0xfff) << 12) |
            (cull_mask << 24);
         child.dword2 =
            min(uint32_t(ceil((child_aabb.max.y - origin.y) / extent.y * float(0x1000))) - 1, 0xfff) |
            (min(uint32_t(ceil((child_aabb.max.z - origin.z) / extent.z * float(0x1000))) - 1, 0xfff) << 12) |
            (encoded_type << 24) | (child_node_size_128b << 28);
         DEREF(dst).children[i] = child;

         set_parent(pack_node_id(dst_offset, encoded_type), node_id);
      }

      /* Set remaining children to invalid */
      for (uint32_t i = found_child_count; i < 8; i++) {
         radv_gfx12_box_child null_child;
         null_child.dword0 = 0xffffffff;
         null_child.dword1 = 0xfff;
         null_child.dword2 = 0;
         DEREF(dst).children[i] = null_child;
      }

      /* Make changes to the children's BVH offset value available to the other invocations. */
      memoryBarrier(gl_ScopeDevice, gl_StorageSemanticsBuffer,
                    gl_SemanticsAcquireRelease | gl_SemanticsMakeAvailable | gl_SemanticsMakeVisible);
      break;
   }

   if (is_root_node) {
      REF(radv_accel_struct_header) header = REF(radv_accel_struct_header)(args.output_base);
      DEREF(header).aabb = src.base.aabb;
      DEREF(header).bvh_offset = args.output_bvh_offset;

      set_parent(RADV_BVH_ROOT_NODE, RADV_BVH_INVALID_NODE);
   }
}
